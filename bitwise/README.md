# Bitwise

## Basic Operator

- `&`: and, 一定要兩個都是1才是1

    * `1` & `1` = `1`
    * `1` & `0` = `0`
    * `0` & `1` = `0`
    * `0` & `0` = `0`
    * `01001011` & `00111100` = `00001000`

- `|`: or, 只要有一個是1就是1

    * `1` | `1` = `1`
    * `1` | `0` = `1`
    * `0` | `1` = `1`
    * `0` | `0` = `0`
    * `01001011` & `00111100` = `01111111`

- `^`: xor, 兩個不一樣才是1

    * `0` ^ `0` = `0`
    * `1` ^ `0` = `1`
    * `0` ^ `1` = `1`
    * `1` ^ `1` = `0`
    * `01001011` ^ `00111100` = `01110111`

- `~`: negate,

    * ~`0` = `1`
    * ~`1` = `0`
    * ~`00000001` = `11111110`
    * ~`01001011` = `10110100`

- `<<`: shift left
    * `111` << 1 = `1110`
    * `111` << 2 = `11100`

- `>>`: shift right
    * `111` >> 1 = `11`
    * `111` >> 2 = `1`

有了這些基本的 operator，就可以做很多事了。

------

觀察

* 1 << 1 == `10`
* 1 << 2 == `100`
* 1 << 3 == `1000`

Q: 要如何產生只有在第 x 個位置為 `1` 的數字呢？

Example:
* one_at(0) = `00000001`
* one_at(2) = `00000100`
* one_at(5) = `00100000`

------

Q: 如何產生只有在第 x 個位置為 `0` 的數字呢？

Example:
* zero_at(0) = `11111110`
* zero_at(2) = `11111011`
* zero_at(5) = `11011111`

------

觀察

`01000100` | `00010000` = `01010100`

Q: 要如何把一個數 x 的第 n 個位置設成 `1` 呢？

Example:
* set_one_at(`10101010`, 0) = `10101011`
* set_one_at(`10101010`, 2) = `10101110`
* set_one_at(`10101010`, 5) = `10101010`

------

Q: 要如何把一個數 x 的第 n 個位置設成 `0` 呢？

Example:
* set_zero_at(`10101010`, 0) = `10101010`
* set_zero_at(`10101010`, 2) = `10101010`
* set_zero_at(`10101010`, 5) = `10001010`

------

Q: 要如何把一個數 x 的第 n 個位置 flip 呢？

Example:
* flip_at(`10101010`, 0) = `10101011`
* flip_at(`10101010`, 2) = `10101110`
* flip_at(`10101010`, 5) = `10001010`

------

Q: 要如何判斷一個數 x 的第 n 個位置是不是 `1` 呢？

Example:
* is_on(`10101010`, 0) = false
* is_on(`10101010`, 2) = false
* is_on(`10101010`, 5) = true

------

會了這些基本操作，恭喜，你已經有能力寫出把 UTF-8 轉成 UTF-16 的程式了。請練習看看，新世代的工程師都應該懂 [UTF-8 是怎麼回事](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)。

## Binary Representation of Numbers

### Unsigned Integer

* 0=`0`
* 1=`1`
* 2=`10`
* 3=`11`
* 4=`100`
* 5=`101`
* 6=`110`
* 7=`111`
* 8=`1000`
* 9=`1001`

多列幾項，觀察一下會形成什麼pattern。

Q: 空格處該填什麼？

* __ = `10000`
* __ = `100000`
* __ = `1000000`
* __ = `11111`
* __ = `111111`
* __ = `1111111`

現在我們可以把數字和bitwise連起來了。

> NOTE: 這邊可以觀察到一些有趣的pattern：
>
> 2的n次方和2的n次方-1
>
> 這和等比級數連結在一起了，我們重新discovered了一條公式：
>
> 1+2+4+8+…2^n = 2^(n+1) - 1
>

* x<<1==x*2
* x<<2==x*4
* x<<4==x*?

你能看出規則嗎？為什麼是這樣？那>>呢？有類似的規則嗎？

### Signed Integer

剛剛講的是unsigned，拓展到signed，負數要如何表達呢？

-x = ~x + 1 （Q: 除了一個數以外。是哪個數呢？）

這是規則，背起來。但為什麼電腦要選這個規則呢？因為這樣加法電路不用重新設計，加上一個負數就直接加就好。

* 1=`00000001`
* -1=`11111110`+1=`11111111`
* -2=`11111101`+1=`11111110`

到這裡，試著回答並弄懂以下問題：

Q: 32bit的unsigned integer可以表達的數值範圍是？

Q: 32bit signed integer可表達的數值範圍是？他們重疊的範圍在哪？不同的在哪？

Q: 有一些小技巧，例如判斷一個數是不是奇數，可以寫 x & 1，為什麼？

Q: x % 8 可以寫成 x & ((1<<3)-1)，為什麼？

Q: 要取一個數最右邊為1的bit（例如 `01010000` 取出 `00010000`），可以寫成x & -x或x & (~x + 1)，為什麼？

Hint: 我們可以來觀察，+1 對 bit pattern有什麼影響？

* 10 + 1: `1010` ⇒ `1011`
* 11 + 1: `1011` ⇒ `1100`
* 12 + 1: `1100` ⇒ `1101`
* 13 + 1: `1101` ⇒ `1110`
* 14 + 1: `1110` ⇒ `1111`
* 15 + 1: `1111` ⇒ `10000`

如果一個數字的binary pattern是 `*****0111111` （前面不管），+1 以後會變怎樣？

## bitwise的應用

知道基本的bitwise操作，寫和硬體溝通、底層的protocol、實作UTF-8轉換、壓縮演算法、二進位檔案格式⋯⋯。寫程式真的會用到。

另外是拿來代替bool array，可以存一堆flag，速度快也省記憶體。

然後是神奇加速法—把想做的事對應到bit操作，就會超快。

- XOR Swap
- popcount
- N-Queen